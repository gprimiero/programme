\documentclass[]{article}
\usepackage{xcolor}
%opening
\title{Logic and Programs:\\
	 a Declaration of (In)dependence}
\author{}
\date{}

\begin{document}

\tableofcontents
\maketitle

%\begin{abstract}
%
%\end{abstract}



\section{Introduction}

How does our Community understand the relation between Logic and Programs? In search for a narrative that could explain such a relation in its many forms, history and politics could come handy. Is Logic a motherland to Programs? Are Programs rebels against the Empire?

Employing this figurative way of speech, the core problem can be formulated as follows: does Logic establish the rule of law according to which Programs have to behave? or do Programs enjoy a freedom of practice, generously allowed by Logic? How much control does a Program need? And how much of the freedom that an implemented Program enjoys from its Logic is given back, and in what terms? Is there a balanced, fruitful, "special relationship" between these two actors? And what does it mean for the design of logical systems and programming languages?

In this chapter we explore and formulate the problems and the opportunities of colonization, of independence and of regulated commerce between Logic and Programs. Our chart will start by establishing the possible forms of constituional relationship within the Empire: Dominion, Federation and Independence. We move, historically and conceptually, from the Empire to a Representative Democracy, where the relationships between Model, Implementation and the Real World are constitutive of the relata: Formalisms, Programs and their Executions. It is here essential to define the relationships and to investigate the resulting ontology of Programs. 


\section{Constitution: Logic as Specification.}

In a first sense, Logic is the Motherland to its colonies, the Programs. Logic intended as the Specification which fixes the behaviour of the Program. This relation answers to the question: what status does the Empire conceeds to the Colony? Or: what is a computer program from a logical point of view?

A possible answer to this question is that of formulating a general regulation, independently of the specifics of the colonies, the language they speak. In this sense, high-level programs can be expressed in many languages and, especially, they can be formulated through different programming language paradigms. Also, the answer will be independent of the material regulations of the colonies, the means they use for production: low-level programs can be expressed in assembly language or in machine-code language, and also in this case the general regulation will have to be formulated independently of such specifics. But what should such a regulation look like, and what ontological constraints shuold it impose? How will the distinct linguistic dialects (paradigms and high-level langaugues) and the local production means (low-level langauges and architecture-dependent machine code) affect the generality of the regulation?


{\color{red}{Ray (links down to Magna Carta)}}


Kowalski at a special meeting of the Royal Society in London emphasises
the relationship between logic programs and specifications. He observe that
the only difference between a complete specification and a program is one of
efficiency.


-- complexity and evaluation as criteria distinguish specification and implementation

-- other level: physical execution


\subsection{Dominion}


{\color{red}{this passage is inspired by Nicola's note}}

According to a first understanding of this problem, given distinct formulations of a program into different programming language paradigms, and distinct compilations into different machine-code languages, the operational nature of the Colony and its relation with the Motherland should remain invariant: the program \textit{is} the same.  Then one way to grasp the logical structure underneath those diverse program formulations (the unique relationship with the Motherland, as established by the Regulation) is to consider the common rule of law that the Emperor has imposed for any Colony: the abstract machine implemented by any program. A C program, a Java program, a Prolog program, are all distinct linguistic formulations, with distinct ontological commitments, of the "same program".


In the tradition, two formulations of this policy have been given:

\begin{itemize}
\item the Curry-Howard isomorphisms
\item denotational semantics
\end{itemize}




{\color{red}{this passage is inspired by Jean-Baptiste's note}}


The former [...]

The latter can be expressed as the set of operations specified by the underlying abstract machine. A program is logically equivalent to the set of
operations it instructs. Imperative, procedural, and object oriented programs make explicit reference to the machine states and operations on those states; logical and functional programming languages leave this duty to the compiler or interpreter.  According to this view, a program can be logically defined as the equivalent class of implementations, expressed using different programming languages, of the same abstract machine. An abstract machine specifies the states of the system to be  implemented , its executions, variables, data types, data structures, algorithms, independently of any chosen programming language. The present view on the nature of programs also accounts for low-level programs: assembly language and machine code programs belong to the equivalence class of programs implementing a given abstract machine. Indeed, both assembly language and machine code programs inherit the abstract machine implemented by some high-level language program.



\subsection{Federation}


{\color{red}{this passage is inspired by Dale's note}}


In many early programming systems, it was specific compilers (and interpreters) that determined the meaning of programs. Since computer processors were rapidly changing and since compilers map high-level languages to these evolving processors, compilers needed to evolve in order to exploit new processor architectures. Since the new compilers did not commit to preserving the same execution behavior of programs
as earlier compilers, the meaning of programs would also change. For
the many people writing high-level code, the fact that their code
could break when moving it between computer systems or to higher
version numbers eventually became a serious problem. This situation
became untenable when programs also grew dependent on the
services -- such as memory management, file systems, and network
access -- offered by operating systems: now programs could also break
whenever there were changes to operating systems.

Early efforts to formalize the meaning of programs employed the
computation-as-model paradigm, i.e. where computing is understood as the process happening in machines, and logic is used to describe what happens. This can be understood as a federative approach, were each region has their own specific regulations, all falling under a certain general one. 
%[Illustrate with Hoare triples]
While this approach to reasoning about the meaning of programs has had
some success and is used in several existing systems today, it has
also had some significant failures. In fact, the topic of model
checking, in which the search for counterexamples (bugs) replaced the
search for formal proofs, arose from frustration that it was too
difficult to use pre- and post-condition reasoning in many systems,
particularly, those that had elements of distributed and concurrent execution.






\subsection{Independence}



{\color{red}{this passage is inspired by Nicola's note}}

According to \cite{turner2018}, contrasting ontological perspectives on the logical nature of programs come from distinct linguistic expressions thereof: 

\begin{itemize}
	\item  high-level programs expressed by means of imperative languages can be defined as sets of operations upon machine states;
	\item  programs should be rather considered mathematical functions if expressed in a functional programming language, or logical sentences when formulated
	through logic languages; 
	\item finally, under the object-oriented paradigm, programs are sets of
	communicating objects. 
\end{itemize}
%
Hence, the nature of the Colonies and how they are treated by the Regulation, differs according to their specificities, language and means of production. 





\section{Representative Democracy: Model, Implementation and the Real World.}



{\color{red}{this passage is inspired by Nick's note}}

Assuming that the form of the relation between Colonies and Motherland within the Empire is either that of the Federation, or rather that of the Dominion, the next question to be explored is: to what extent do Colonies depend on the Regulation, and thereby how much do they depend on the Empire? Or, out of the analogy, to what extent do computer programs depend on logic?

The question has a metaphysical motivation, and its answer necessarily aims for a better understanding of the ontological status of computer programs by analyzing the kind and degree of dependence. In metaphysics there are different forms of so called ontological dependence, often spelled out in modal terms. For instance:

\begin{quote}
$x$ depends for its existence upon y $=_{df}$\\
Necessarily, $x$ exists only if $y$ exists.
\end{quote}
%
Illuminating the kind of ontological dependence of entities $x$ upon $y$ (in
our case $x$ = "Colony" and $y$ = "Motherland"; or $x$ = "computer programs" and $y$ = "logic") may help one to better understand the ontological status of $x$. How does the original question about the dependence of computer programs to logic help us understand the the nature of the former? 

Even though the question has a clearly philosophical connotation, it can
not only be approached from a philosophical angle, but also from a historical
and a practical perspective. For instance, has the relationship (especially
“ontological dependence”) between logic and computer programs historically
always been the same? Can there be (historically) identified different kinds of
dependence relations between computer programs and logic? Shedding light
on these issues may help us to find an answer to the original question “To
what extent do computer programs depend on logic?”, which in turn would
largely benefit our understanding of the metaphysics of programs in general.


\subsection{The Dual Nature View}

Many philosophical view support the so called dual-nature view; on the one hand, computer programs causally interact with the world and “do something”, they are physical (in a certain way); on the other hand they are perceived as these abstract-mathematical-object like entities, which don't bear any physical properties.
Take for contrast, regular “material objects” like rocks or tigers -- they
seem to lack any ontological dependence from “logic”. In other words, logic is
not an integral ingredient of what constitutes those objects as being rocks or
tigers. 

Mathematical objects on the other hand, appear to be largely contingent on logic (in one form or another). But how is the situation then when it comes to computer programs? Is logic really an over and above necessary ingredient for constituting a computer program? Could there be computer programs without logic and what, subsequently, are the ramifications for the understanding of their ontological status?

\subsection{The Layered Ontology View}

%GP

{\color{red}{this passage follows on Nicola's and Giuseppe's work for SEP}}

\subsection{The Third Way: Pragmatism}


%??
{\color{red}{this passage does not exist. A student of mine is doing some work in this direction, wonder whether we should explore.}}



\section{The Parties: Declarativists and Constructivists.}


{\color{red}{Ray's}}

Logic programming versus constructive programming. They have different notions of computation and program. Philosophical differences in underlying semantics of the specification rather than the programs. In constructive approach the type is the specification that has constructive content that is unpacked in terms of the programs that provide witness to the truth of the proposition. In the logic paradigm the logical assertion is both the specification and the program but is given different interpretations – with all that is entailed by calling it a specification. Namely as assertion it provides the correctness criteria for its guise as program. This is reflected in the difference between the truth conditional and the operational semantics. 



\section{Regulations: Types in Logic and Programming.}


{\color{red}{Tomas?}}



\section{Magna Carta: Linguistic Variants.}

{\color{red}{Ray's note}}

The different programming language paradigms impact upon the nature of programs. Roughly, different paradigms would seem to generate different notions of program. Functional, procedural, object oriented and logical paradigms present different notions of what a program is and different notions of computation. This provides a philosophical and historical perspective on the question what is a program. The parallel, non-deterministic dimension also contributes to the notion of program. On the other hand, are there aspects of programs that transcend the paradigms? 



\section{Habitus: Contexts and Practices.}


\subsection{Different Implementations}

{\color{red}{GP?}}

The ontological analysis of the nature of computer programs from a logical perspective is connected to the analysis of programs from the software systems viewpoint. Given the abstraction level hierarchy defining software systems, answering to the question “what is a (logic) program?” amounts to identifying the level of abstraction that better grasps the (logical) nature of programs. Choosing, as one might expect,
the high-level language program level is reducing, insofar as assembly language and machine
code programs would be ruled out. By contrast, by focusing on higher levels of abstraction, such
as the level of formal specifications, one would include too many entities in the equivalence
class defined by the programs implementing the same specifications. Indeed, the same
specification may be realized by different algorithms and consequently different programs which
do not necessarily share the same set of states, operations, data types and structure.


\subsection{Verification}


{\color{red}{Note by Selmer on Different notions of Verification. Can he turn it into something that fits here?}}



\section{Loopholes: Limits and Approximations.}

\subsection{Pathology vs. Correctness}

{\color{red}{Liesbeth?}}



\subsection{The Kopetz Principle}%EDGAR

{\color{red}{Passage inspired by Edgar}}


\begin{quote}
	Many (predictive) properties that we assert about systems (determinism, timeliness, reliability, and correctness) are in fact not properties of an implemented system, but rather properties of a model of	the system.
	We can make definitive statements about
	models, from which we can infer properties of system realizations. The validity of this inference depends on model fidelity , which is always approximate.
\end{quote}



\section{Dialogue: Another Role for Formal Methods.}

{\color{red}{Passage inspired by Liesbeth}}


In the introduction of the well-known and early collection of papers on the
history of computing, one reads \cite[p???]{??}:

\begin{quote}
The improbable symbolism of Peano, Russel, and Whitehead, the
analysis of proofs by fowcharts spearheaded by Gentzen, the definition of computability by Church and Turing, all inventions motivated by the purest of mathematics, mark the beginning of the computer revolution. Once more, we find a confirmation of the sentence Leonardo jotted despondently on one of those rambling sheets where he confided his innermost thoughts: `Theory is the captain,
and application the soldier.' 
\end{quote}

The viewpoint of theory (logic) being the captain and the application (program) being the soldier requires that their role be strictly separated, both historically and
epistemologically. This requirement appears difficult to satisfy. Arguably, a lot of the so-called theoretical foundations have been retro-fitted to the discourse; e.g, the idea that theoretical insights from the 1930s were the historical basis for the first computers. Hence, this approach seems the result of much academic strategy.

Much motivation for developing logical and formal approaches are driven by
the idea of a kind of perfect program, where, perfect means, being in control of
everything; having certainty that there are no errors and that there will be no
errors. But being in control also means that one is limiting the
possibilities of something else (the machine, the user, the language, etc). 
The history of computing, however, is full of examples where lack of
control is exactly what is needed to make progress. One basic question might
be in which contexts such complete control is desired and if that is achievable.
Perhaps one well-known example is Turing's insistence on the machine's
ability to make mistakes. This seems an important precondition in order to
have genuine machine intelligence.

On the other hand, the view that application should be seen too much as the captain is the more popular view since the 1980s, not just in computing, but in science at large, see e.g. \cite{forman}. Considering different cases from the history of Computing,  captain-like statements with respect to logic have had signifcant consequences,  intensifying certain communication gaps. Alongside such gaps, physical computing systems seem to remain opaque, despite the (extensive or entirely missing) effort of formalization. 
%Why formal approaches have not managed to control the opacity problem in computational systems? do we know a purely "logical" program? do we know a purely "illogical" program?





\end{document}


\section{Topics and problems around Logic and Programs}

The list of topics emerging from the individual contributions, and which could be seen as sections:

\begin{enumerate}

\item \textit{Constitution}: logic as specification 
\item \textit{Independence}: relation model-implementation
\item \textit{Representative Democracy}: program vs. model of programs
\item \textit{The Parties}: declarative and constructivist traditions

\item \textit{Controlled behaviours}: types in logic and in programming

\item \textit{Magna Carta}: distinct linguistic levels of formulations for the same program
\item \textit{Habitus}: notion of logic contextual on practices
%http://criticallegalthinking.com/2019/08/06/pierre-bourdieu-habitus/
\item \textit{Loopholes in the Constitution}: perfection/limitation vs. approximation/improvement
\item \textit{Transparency and Dialogue}: another role for formal methods
%: opacity and communication gaps
%- the what (specification) and the how (implementation), (in my terminology the blueprint and the design)-- see programming paradigm


\end{enumerate}

%%--- Mathematical definitions of functions are to be read axiomatically and provide no mechanism of evalua-
%tion. Lazy evaluation allows the language run-time to discard sub-expressions
%that are not directly linked to the final result of the expression. It reduces the
%time complexity of an algorithm by discarding the temporary computations and
%conditionals etc. etc. None of this concerns the specification of the intended
%function which is defintional and axiomatically given.
%
%
%--- Kowalski at a special meeting of the Royal Society in London emphasises
%the relationship between logic programs and specifications. He observe that
%the only difference between a complete specification and a program is one of
%efficiency.
%
%
%-- complexity and evaluation as criteria distinguish specification and implementation
%
%-- other level: physical execution


\section{Issues in preparing this chapter}


The main issue in preparing this chapter is necessarily that we do not share the same view, and we cannot possibly hope to present a position paper. But, it seems, we do share the same problem. Moreover, the editors wants us to provide something different to the literature: not another paper that present some approach and some solution to a problem.\\

We will need to collaborative and find the narrative and the style. What I have proposed above is a conceptual reading of the problem that arises in all short abstract that were sent to me: colonization and independence as the duality that regulates the life of the Empire and the Colonies. The way to proceed is unclear: we might assign the sections specified above to one or more authors (based on their proposals) and then mold everything together with a unified approach.\\

I am open to objections, criticisms and firm oppositions to the project in this form. We are in a representative democracy, bordering a direct democracy. I am sorry for the constitutional monarchists.

\section{Connections to other Chapters}

\begin{enumerate}

\item Machines
\item ?
\end{enumerate}


\section{Ideas for possible Programs to start with}


\begin{itemize}

\item A program written in Curry's notation
\item A Coq program
\end{itemize}

These two examples share a lot in common: logical and physical, control, notation, correctness. Other examples welcome.

\end{document}
