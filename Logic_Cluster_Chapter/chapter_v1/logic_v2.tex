\documentclass[]{article}
\usepackage{xcolor}
\usepackage{amsmath,amssymb}
%opening
\title{Logic and Programs:\\
	 a Declaration of (In)dependence}
\author{}
\date{}


\begin{document}
\tableofcontents
\maketitle


%\begin{abstract}
%
%\end{abstract}



\section{Introduction}

The relation between logic and programs, and the issue of which one between formal and applied structure come prior, is a core issue.

%make explicit the sociological relation between more and less- logically-oriented actors.

Is Logic a motherland to Programs? Does Logic establish the rule of law according to which Programs have to behave? or do Programs enjoy a freedom of practice, generously allowed by Logic? Can Programs rebel against the Empire of Logic? How much control does a Program need? Is there a balanced, fruitful, "special relationship" between these two actors? And what does it mean for the design of logical systems and programming languages?

In this chapter we explore and formulate the problems and the opportunities of colonization, of independence and of regulated commerce between Logic and Programs. Our chart will start by establishing the possible forms of constituional relationship within the Empire: Dominion, Federation and Independence. We move, historically and conceptually, from the Empire to a Representative Democracy, where the relationships between Model, Implementation and the Real World are constitutive of the relata: Formalisms, Programs and their Executions. It is here essential to define the relationships and to investigate the resulting ontology of Programs.


\section{Before dominion}



[Based on a remark by Marie-Jo] The chapter starts out with an idea of dominion but of course, that relation between logic and programs was not fixed from the start. A more historical section on how these relations came to be, should perhaps be explicated here.


\section{Constitution: Logic as Specification.}

In a first conceptual sense, Logic is the Motherland to its colonies, the Programs. Logic is in this way intended as the specification which fixes the behaviour of the Program. Under this reading, the relation between logic and programs is one of magnanimity of the former towards the latter ones: which status does the Empire concedes to its colonies? Or else: what can a computer program be, when intended from a logical point of view?

Answering this question means formulating a general regulation dictated by the specifics of the chosen logic, independently of the implementation details within  the colonies, i.e. the language they speak, or the material conditions (hardware) in which they live. In this sense, high-level programs can be expressed in many languages and, especially, they can be formulated through different programming language paradigms, but these are accidental properties irrelevant to the correct execution of the law. Also, the latter will be independent of the material regulations of the colonies, their means of production: low-level programs can be expressed in assembly language or in machine-code language; and they can be compiled for a given processor, or another; but also in this case the general regulation will hold independently of such specifics, and the behaviour of programs will be evaluated for correctness against such regulation.

But what should such a regulation look like, and what ontological constraints should impose? How will the distinct linguistic dialects (paradigms and high-level langaugues) and the local production means (low-level langauges and architecture-dependent machine code) affect the generality of the regulation?




\subsection{Dominion}


{\color{red}{this passage is inspired by Nicola's note}}

Hence, given distinct formulations of a program into different programming language paradigms, and distinct compilations into different machine-code languages, the operational nature of the Colony and its relation with the Motherland remains invariant: the program \textit{is} the same.  Then one way to grasp the logical structure underneath those diverse program formulations (the unique relationship with the Motherland, as established by the Regulation) is to consider the common rule of law that the Emperor has imposed for any Colony: the abstract machine implemented by any program. A C program, a Java program, a Prolog program, are all distinct linguistic formulations, with distinct ontological commitments, of the "same program".

In the tradition, two formulations of this policy have been given:

\begin{itemize}
\item the Curry-Howard isomorphisms
\item denotational semantics
\end{itemize}




{\color{red}{this passage is inspired by Jean-Baptiste's note}}


The former [...]

The latter can be expressed as the set of operations specified by the underlying abstract machine. A program is logically equivalent to the set of
operations it instructs. Imperative, procedural, and object oriented programs make explicit reference to the machine states and operations on those states; logical and functional programming languages leave this duty to the compiler or interpreter.  According to this view, a program can be logically defined as the equivalent class of implementations, expressed using different programming languages, of the same abstract machine. An abstract machine specifies the states of the system to be  implemented , its executions, variables, data types, data structures, algorithms, independently of any chosen programming language. The present view on the nature of programs also accounts for low-level programs: assembly language and machine code programs belong to the equivalence class of programs implementing a given abstract machine. Indeed, both assembly language and machine code programs inherit the abstract machine implemented by some high-level language program.


{\color{red}{(Selmer:) A good program P from the pov of a rational mind M is one that M has rigorous reason to believe will behave correctly upon execution. Without logic, “rigorous reason” cannot be meaningfully explicated. Therefore, all good program require logic. (Note that “logic” includes “inductive logic.”) }}

{\color{red}{Ray (links down to Magna Carta)}}


Kowalski at a special meeting of the Royal Society in London emphasises
the relationship between logic programs and specifications. He observe that
the only difference between a complete specification and a program is one of
efficiency.


-- complexity and evaluation as criteria distinguish specification and implementation

-- other level: physical execution


\subsection{The Motherland is Vast; The Colony, Hitherto, Tiny}
\label{sect:motherlandvast_colonytiny}

\noindent
%
Once Logic is taken to be the Motherland, and programs as most humans
have so far created and used them taken to be a Colony, say
$C_\textsc{<h}$, an immediate moral from the metaphor is that the
Motherland is breathtakingly larger and richer than what has been seen
in $C_\textsc{<h}$.  Put another way, the colony $C_\textsc{<h}$ is
tiny; but the Motherland is vast, with glorious riches and raw
materials entirely absent from, and not even faintly reflected by
anything in, $C_\textsc{<h}$.  What has been introduced as Pure
General Logic Programming (PGLP) \cite{introduction_of_PGLP} makes
this clear; the tiny-vs.-vast moral also follows from the view,
defended in \cite{comp_sci_immaterial_formal_logic}, that past and
present programming, and indeed computer science overall, is a small
fragment of formal logic.

These are abstract concepts, yet even simple examples can be used to
reveal the moral brought to the reader's attention in the present
section.  For example, where the background formal language is an
infinitary one for the standard propositional calculus that permits
countably infinite disjunctions and conjunctions\footnote{The formal
	language here is the propositional fragment of that for the
	well-behaved infinitary logic $\mathscr{L}_{\omega_1 \omega}$,
	economically covered in \cite{ebb.flum.thomas.2nded}.}, here is a
two-line program $\mathbb{P}_1$ in PGLP from the Motherland, hereby
brought to $C_\textsc{<h}$:

\medskip
$$
\begin{array}{l|l}
1 &  \phi_1 \vee \phi_2 \vee \phi_3 \ldots\\
2 & \neg \phi_2 \wedge \neg \phi_3 \wedge \neg \phi_4 \ldots
\end{array}
$$
\medskip

\noindent
%
The query ``$\phi_1$?'' against $\mathbb{P}_1$ then results in an
affirmative answer, and the proof makes use of an infinitary analogue
of \textit{disjunctive syllogism} or \textit{unit resolution}.


\subsection{Federation}


{\color{red}{this passage is inspired by Dale's note}}


In many early programming systems, it was specific compilers (and interpreters) that determined the meaning of programs. Since computer processors were rapidly changing and since compilers map high-level languages to these evolving processors, compilers needed to evolve in order to exploit new processor architectures. Since the new compilers did not commit to preserving the same execution behavior of programs
as earlier compilers, the meaning of programs would also change. For
the many people writing high-level code, the fact that their code
could break when moving it between computer systems or to higher
version numbers eventually became a serious problem. This situation
became untenable when programs also grew dependent on the
services -- such as memory management, file systems, and network
access -- offered by operating systems: now programs could also break
whenever there were changes to operating systems.

Early efforts to formalize the meaning of programs employed the
computation-as-model paradigm, i.e. where computing is understood as the process happening in machines, and logic is used to describe what happens. This can be understood as a federative approach, were each region has their own specific regulations, all falling under a certain general one.
%[Illustrate with Hoare triples]
While this approach to reasoning about the meaning of programs has had
some success and is used in several existing systems today, it has
also had some significant failures. In fact, the topic of model
checking, in which the search for counterexamples (bugs) replaced the
search for formal proofs, arose from frustration that it was too
difficult to use pre- and post-condition reasoning in many systems,
particularly, those that had elements of distributed and concurrent execution.






\subsection{Independence}



{\color{red}{this passage is inspired by Nicola's note}}

According to \cite{turner2018}, contrasting ontological perspectives on the logical nature of programs come from distinct linguistic expressions thereof:

\begin{itemize}
	\item  high-level programs expressed by means of imperative languages can be defined as sets of operations upon machine states;
	\item  programs should be rather considered mathematical functions if expressed in a functional programming language, or logical sentences when formulated
	through logic languages;
	\item finally, under the object-oriented paradigm, programs are sets of
	communicating objects.
\end{itemize}
%
Hence, the nature of the Colonies and how they are treated by the Regulation, differs according to their specificities, language and means of production.





\section{Representative Democracy: Model, Implementation and the Real World.}



{\color{red}{this passage is inspired by Nick's note}}

Assuming that the form of the relation between Colonies and Motherland within the Empire is either that of the Federation, or rather that of the Dominion, the next question to be explored is: to what extent do Colonies depend on the Regulation, and thereby how much do they depend on the Empire? Or, out of the analogy, to what extent do computer programs depend on logic?

The question has a metaphysical motivation, and its answer necessarily aims for a better understanding of the ontological status of computer programs by analyzing the kind and degree of dependence. In metaphysics there are different forms of so called ontological dependence, often spelled out in modal terms. For instance:

\begin{quote}
$x$ depends for its existence upon y $=_{df}$\\
Necessarily, $x$ exists only if $y$ exists.
\end{quote}
%
Illuminating the kind of ontological dependence of entities $x$ upon $y$ (in
our case $x$ = "Colony" and $y$ = "Motherland"; or $x$ = "computer programs" and $y$ = "logic") may help one to better understand the ontological status of $x$. How does the original question about the dependence of computer programs to logic help us understand the the nature of the former?

Even though the question has a clearly philosophical connotation, it can
not only be approached from a philosophical angle, but also from a historical
and a practical perspective. For instance, has the relationship (especially
“ontological dependence”) between logic and computer programs historically
always been the same? Can there be (historically) identified different kinds of
dependence relations between computer programs and logic? Shedding light
on these issues may help us to find an answer to the original question “To
what extent do computer programs depend on logic?”, which in turn would
largely benefit our understanding of the metaphysics of programs in general.


\subsection{The Dual Nature View}

Many philosophical view support the so called dual-nature view; on the one hand, computer programs causally interact with the world and “do something”, they are physical (in a certain way); on the other hand they are perceived as these abstract-mathematical-object like entities, which don't bear any physical properties.
Take for contrast, regular “material objects” like rocks or tigers -- they
seem to lack any ontological dependence from “logic”. In other words, logic is
not an integral ingredient of what constitutes those objects as being rocks or
tigers.

Mathematical objects on the other hand, appear to be largely contingent on logic (in one form or another). But how is the situation then when it comes to computer programs? Is logic really an over and above necessary ingredient for constituting a computer program? Could there be computer programs without logic and what, subsequently, are the ramifications for the understanding of their ontological status?

\subsection{The Layered Ontology View}

%GP

{\color{red}{this passage follows on Nicola's and Giuseppe's work for SEP}}

\subsection{The Third Way: Pragmatism}


%??
{\color{red}{this passage does not exist. A student of mine is doing some work in this direction, wonder whether we should explore.}}



\section{The Parties: Declarativists and Constructivists.}


{\color{red}{Ray's}}

Logic programming versus constructive programming. They have different notions of computation and program. Philosophical differences in underlying semantics of the specification rather than the programs. In constructive approach the type is the specification that has constructive content that is unpacked in terms of the programs that provide witness to the truth of the proposition. In the logic paradigm the logical assertion is both the specification and the program but is given different interpretations – with all that is entailed by calling it a specification. Namely as assertion it provides the correctness criteria for its guise as program. This is reflected in the difference between the truth conditional and the operational semantics.



\section{Regulation and Enforcement: Types in Logic and Programming.}


In the perspective put forward in this chapter, Logic is the Motherland to Programs or Colonies. As we have seen, the relationship can have a variety of formats. On the one hand, if the Motherland rules with absolutist powers, the Colonies do not have any independence -- programs become just specific implementations of an abstract specification given by logic. On the other hand, after the Declaration of Independence, the Motherland and (former) Colonies become equal partners -- logic and programs can still exchange ideas, but they exist independently.

Following our metaphor, we need to ask: In situations when the Motherland exerts some power over the Colonies, what can be the regulatory mechanism for doing this and what is the military force used to enforce such regulations? The most common way in which Logic is embedded in Programs is using \emph{types}. Here we look at the different ways in which the regulatory mechanism of types can be used in the relationship between the Motherland/Logic and the Colonies/Programs. A full historical account of types, that adds an extra level of detail, is presented later in Chapter~X.

\subsection{Types as a Regulatory Mechanism}
In programming languages with static type systems, types are an artifact from the Motherland that is embedded in the Colonies. To quote a standard contemporary textbook on types in programming languages \cite{pierce2002types}:

\begin{quotation}
\emph{Modern software engineering recognizes a broad range of formal methods for helping ensure that a system behaves correctly with respect to some specification. (...) On one end of the spectrum are powerful frameworks such as Hoare logic, algebraic specification languages, modal logics, and denotational semantics. These can be used to express very general correctness properties but (...) demand a good deal of sophistication on the part of programmers. At the other end are techniques of much more modest power--modest enough that automatic checkers can be built [and] applied even by programmers unfamiliar with the underlying theories. (...) But by far the most popular and best established lightweight formal methods are type systems.}
\end{quotation}

The quote contrasts denotational semantics, discussed earlier in this chapter, with lightweight  formal methods such as type systems. In case of denotational semantics, the program in the Motherland and the (operational) program in the Colony are the same. In case of type systems, entities from the Motherland, i.e.~types, are embedded in the Colony and enforce the law.

The law restricts what can be done in the Colonies. Consider, for example, the following operation, implemented in statically typed Java language (left) and in untyped JavaScript (right):\footnote{Here, we consider types as logicians, as a purely static checking mechanism, so we ignore the fact that JavaScript also uses the notion of types, but for runtime checking.}

\begin{verbatim}
// Typed Java example          // Untyped JavaScript example
void barkTwice(Dog d) {        function barkTwice(d) {
  d.bark();                      d.bark();
  d.bark();                      d.bark();
}                              }
\end{verbatim}

The presence of a type in the method argument \texttt{Dog d} in Java restricts the range of  arguments that can be given to the operation. Only a dog can bark twice; a coyote can not. Without such regulation, the operation can also operate on foxes or coyotes. However, the law also gives us certain guarantees. If types enforce laws in the Colony, a cat can never even attempt to bark twice.

The important point here is that a type, such as \texttt{Dog} in our example, is now a representative of the Motherland embedded in the Colony, checking that laws are being followed. The question that remains is, where do these laws come from? There are two basic options. In modern programming languages, the two are often mixed and conflated, but as is apparent from the history outlined in Chapter~X, the two have different historical origins.

\subsection{Data Types, or Supervised Self-Governance}

One historical strand through which types appeared in the Colonies followed the model of gradually developing self-governance, which was later blessed and assisted by the Motherland. The first use of types in programs was to make sense of data stored in computer memory. Types appeared as a mechanism to describe what the data in memory mean: an \texttt{INT} means the bits represent an integer, whereas \texttt{REAL} instructs us to interpret the data as a real number and operate on it accordingly.

This use of types initially shared little with types as known from logic. The Colonies initially developed their own regulations, without the wisdom that might have been available from the Motherland.

One such development is the type for passing functions as arguments to other functions. This operation was supported in ALGOL 60, but the type of the argument was just \texttt{PROCEDURE}. It did not specify what the valid arguments for the procedure are and what it might return. This is not sufficient to provide a safety guarantee about the use of procedures as they can be invoked with an invalid argument.

Of course, the Motherhood had a solution for such situation. In the simply typed $\lambda$-calculus, the type of a function is not just \texttt{PROCEDURE}, but rather $\tau_1 \rightarrow \tau_2$ where $\tau_1$ is a type of the argument and $\tau_2$ is the type of the result. This adds the necessary information to guarantee safety. After the self-governing Colonies recognized that the structure of the law they began to define is, in fact, the same as a law that exists in the Motherland, they began incorporating mechanisms from the Motherland and the type for procedures in Algol 68 became, e.g.~\texttt{PROC (REAL) REAL} for a procedure taking a real number and returning a real number.

In this historical strand, types appear as a regulatory mechanism in the Colonies that autonomously begin self-regulating. The Colonies recognize the usefulness of a supervision offered by the Motherland and use it as appropriate, though not always.\footnote{An example here is the use of types in TypeScript programs. TypeScript is well aware of the logical structure of types that is available from the Motherland, but chooses to ignore some aspects of it for pragmatic reasons, intentionally ending with a type system that is unsound. The Rebellion against the Motherland has caused some uproar in the online newsgroups dedicated to programming language theory, but has, arguably, been otherwise successful.}

\subsection{Logic Types, or Imposed Rule of The Law}

The second historical strand through which types appeared in the Colonies followed a model where the Motherland more directly exerts its power over the Colonies. Types have been known to the Motherland even before Colonies existed. The foundational work on types for logic and the $\lambda$-calculus by Bertrand Russell and Alonzo Church was done in the first half of the $20^{th}$ century. However, this had little direct influence on the idea of types that appeared in the Colonies in 1960s, until the programming langauge ML appeared in 1970s.

In ML, the notion of types was directly based on the types in logic. In other words, the Motherland imposed the rules on the Colonies. The regulations are shaped by the Motherland in order to provide the guarantees that the Motherland is able to offer when it is strictly followed without exceptions.

In the case of the ML language, the guarantees offered by the type system are, indeed, strong ones. ML appeared as a meta-language for the theorem prover LCF. It was used for writing code to automatically search for and construct proofs. Types were used to ensure that all proofs constructed using ML programs are, in fact, valid proofs.

The ML language is an early example of a situation where the Motherland imposes the rule of law on its Colonies, but certainly not the only one. Many type systems directly based on various developments of logic appeared since the 1970s, such as those for dependently typed langauges, based on constructive theory of types. In all of those, the Colonies are actually allowed some flexibility in how they implement the law in their legal system. The Motherland provides a template and requires that the Colonies follow one key principle. Unlike in the model of supervised self-governance, the type system that implements a logic provided by the Motherland has to be free of contradictions.

{\color{red}{Tomas?}}

{\color{red}{Wendy?}}

\section{Magna Carta: Linguistic Variants.}

{\color{red}{Ray's note}}

The different programming language paradigms impact upon the nature of programs. Roughly, different paradigms would seem to generate different notions of program. Functional, procedural, object oriented and logical paradigms present different notions of what a program is and different notions of computation. This provides a philosophical and historical perspective on the question what is a program. The parallel, non-deterministic dimension also contributes to the notion of program. On the other hand, are there aspects of programs that transcend the paradigms?



\section{Habitus: Contexts and Practices.}


\subsection{Different Implementations}

{\color{red}{GP?}}

The ontological analysis of the nature of computer programs from a logical perspective is connected to the analysis of programs from the software systems viewpoint. Given the abstraction level hierarchy defining software systems, answering to the question “what is a (logic) program?” amounts to identifying the level of abstraction that better grasps the (logical) nature of programs. Choosing, as one might expect,
the high-level language program level is reducing, insofar as assembly language and machine
code programs would be ruled out. By contrast, by focusing on higher levels of abstraction, such
as the level of formal specifications, one would include too many entities in the equivalence
class defined by the programs implementing the same specifications. Indeed, the same
specification may be realized by different algorithms and consequently different programs which
do not necessarily share the same set of states, operations, data types and structure.


\subsection{Verification}


{\color{red}{Note by Selmer on Different notions of Verification. Can he turn it into something that fits here?}}



\section{Loopholes: Limits and Approximations.}

\subsection{Pathology vs. Correctness}

{\color{red}{Liesbeth?}}



\subsection{The Kopetz Principle}%EDGAR

{\color{red}{Passage inspired by Edgar}}


\begin{quote}
	Many (predictive) properties that we assert about systems (determinism, timeliness, reliability, and correctness) are in fact not properties of an implemented system, but rather properties of a model of	the system.
	We can make definitive statements about
	models, from which we can infer properties of system realizations. The validity of this inference depends on model fidelity , which is always approximate.
\end{quote}



\section{Dialogue: Another Role for Formal Methods.}

{\color{red}{Passage inspired by Liesbeth}}


In the introduction of the well-known and early collection of papers on the
history of computing, one reads \cite[p???]{??}:

\begin{quote}
The improbable symbolism of Peano, Russel, and Whitehead, the
analysis of proofs by fowcharts spearheaded by Gentzen, the definition of computability by Church and Turing, all inventions motivated by the purest of mathematics, mark the beginning of the computer revolution. Once more, we find a confirmation of the sentence Leonardo jotted despondently on one of those rambling sheets where he confided his innermost thoughts: `Theory is the captain,
and application the soldier.'
\end{quote}

The viewpoint of theory (logic) being the captain and the application (program) being the soldier requires that their role be strictly separated, both historically and
epistemologically. This requirement appears difficult to satisfy. Arguably, a lot of the so-called theoretical foundations have been retro-fitted to the discourse; e.g, the idea that theoretical insights from the 1930s were the historical basis for the first computers. Hence, this approach seems the result of much academic strategy.

Much motivation for developing logical and formal approaches are driven by
the idea of a kind of perfect program, where, perfect means, being in control of
everything; having certainty that there are no errors and that there will be no
errors. But being in control also means that one is limiting the
possibilities of something else (the machine, the user, the language, etc).
The history of computing, however, is full of examples where lack of
control is exactly what is needed to make progress. One basic question might
be in which contexts such complete control is desired and if that is achievable.
Perhaps one well-known example is Turing's insistence on the machine's
ability to make mistakes. This seems an important precondition in order to
have genuine machine intelligence.

On the other hand, the view that application should be seen too much as the captain is the more popular view since the 1980s, not just in computing, but in science at large, see e.g. \cite{forman}. Considering different cases from the history of Computing,  captain-like statements with respect to logic have had signifcant consequences,  intensifying certain communication gaps. Alongside such gaps, physical computing systems seem to remain opaque, despite the (extensive or entirely missing) effort of formalization.
%Why formal approaches have not managed to control the opacity problem in computational systems? do we know a purely "logical" program? do we know a purely "illogical" program?


%Re meaning, including meaning of programs and natural language regarding them: Is there any reason/desire to include a purely inferential approach to meaning (of expressions in both natural and formal languages)? This is a generalization of proof-theoretic semantics. I have a first simple paper on setting this out and defending it: http://kryten.mm.rpi.edu/SBringsjordetal_HouseholdRobotsHIS.pdf

\bibliographystyle{plain}
\bibliography{logic}



\end{document}


\section{Topics and problems around Logic and Programs}

The list of topics emerging from the individual contributions, and which could be seen as sections:

\begin{enumerate}

\item \textit{Constitution}: logic as specification
\item \textit{Independence}: relation model-implementation
\item \textit{Representative Democracy}: program vs. model of programs
\item \textit{The Parties}: declarative and constructivist traditions

\item \textit{Controlled behaviours}: types in logic and in programming

\item \textit{Magna Carta}: distinct linguistic levels of formulations for the same program
\item \textit{Habitus}: notion of logic contextual on practices
%http://criticallegalthinking.com/2019/08/06/pierre-bourdieu-habitus/
\item \textit{Loopholes in the Constitution}: perfection/limitation vs. approximation/improvement
\item \textit{Transparency and Dialogue}: another role for formal methods
%: opacity and communication gaps
%- the what (specification) and the how (implementation), (in my terminology the blueprint and the design)-- see programming paradigm


\end{enumerate}

%%--- Mathematical definitions of functions are to be read axiomatically and provide no mechanism of evalua-
%tion. Lazy evaluation allows the language run-time to discard sub-expressions
%that are not directly linked to the final result of the expression. It reduces the
%time complexity of an algorithm by discarding the temporary computations and
%conditionals etc. etc. None of this concerns the specification of the intended
%function which is defintional and axiomatically given.
%
%
%--- Kowalski at a special meeting of the Royal Society in London emphasises
%the relationship between logic programs and specifications. He observe that
%the only difference between a complete specification and a program is one of
%efficiency.
%
%
%-- complexity and evaluation as criteria distinguish specification and implementation
%
%-- other level: physical execution


\section{Issues in preparing this chapter}


The main issue in preparing this chapter is necessarily that we do not share the same view, and we cannot possibly hope to present a position paper. But, it seems, we do share the same problem. Moreover, the editors wants us to provide something different to the literature: not another paper that present some approach and some solution to a problem.\\

We will need to collaborative and find the narrative and the style. What I have proposed above is a conceptual reading of the problem that arises in all short abstract that were sent to me: colonization and independence as the duality that regulates the life of the Empire and the Colonies. The way to proceed is unclear: we might assign the sections specified above to one or more authors (based on their proposals) and then mold everything together with a unified approach.\\

I am open to objections, criticisms and firm oppositions to the project in this form. We are in a representative democracy, bordering a direct democracy. I am sorry for the constitutional monarchists.

\section{Connections to other Chapters}

\begin{enumerate}

\item Machines
\item ?
\end{enumerate}


\section{Ideas for possible Programs to start with}


\begin{itemize}

\item A program written in Curry's notation
\item A Coq program
\end{itemize}

These two examples share a lot in common: logical and physical, control, notation, correctness. Other examples welcome.


\end{document}
